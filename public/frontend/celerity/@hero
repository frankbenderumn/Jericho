<style>
    .celerity-hero {
        background-image:url("$[iyield]{img}$");
    }
    .celerity-gradient {
        background: linear-gradient(to bottom,  #003b07 0%,#23ae2f 100%); /* W3C, IE10+, FF16+, */
    }
</style>
<!-- background-image:url('../assets/images/matrix-green.jpg');background-size: cover; -->
<div id="celerity-container" class="hero celerity-gradient" style="color:white;width:100%;height:800px;background-image:url('../assets/images/matrix2.png');background-size: cover;">
    <!-- <div style="background-color:#000;height:100%;z-index:999;position:absolute;"> &nbsp;</div> -->
    <div class="stage" style="position:relative;top:200px;">
    <H1 class="font-borned" style="font-size:4em;">$[iyield]{title}$<h1>
    <h4 class="font-borned">$[iyield]{subtitle}$<h4>
    </div>
</div>
<div style="background-color:red;" class="celerity-gradient">
<div style="height:200px;"></div>
</div>

<!-- <script>
    let container = document.getElementById('celerity-container');
    // container.className = 'zstack-child';
    let width = window.innerWidth;
    let height = 800;
    // renderer = new THREE.WebGLRenderer();
    // renderer.setSize( 200, 200 );

    const scene = new THREE.Scene();
    // scene.background = new THREE.Color( 0x002266 );
    const camera = new THREE.PerspectiveCamera( 75, width / height, 0.1, 1000 );

    var horizontalFov = 120;
    camera.fov = (Math.atan(Math.tan(((horizontalFov / 2) * Math.PI) / 180) / camera.aspect) * 2 * 180) / Math.PI;

    const renderer = new THREE.WebGLRenderer();
    renderer.autoClear = false;
    renderer.setClearColor(0x000000, 0.0);
    renderer.setSize( width, height );
    // document.body.appendChild( renderer.domElement );
    container.appendChild( renderer.domElement );
    // document.body.appendChild( container );

    const ambientLight = new THREE.AmbientLight( 0x404055 ); // soft white light
    scene.add( ambientLight );

    const directionalLight = new THREE.DirectionalLight( 0xffffff, 1.0 );
    scene.add( directionalLight );

    const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 0.2 );
    scene.add( light );

    const controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    //controls.update() must be called after any manual changes to the camera's transform
    camera.position.set( 0, 3, 20 );
    controls.update();

        // const geometry = new THREE.BoxGeometry( 1, 1, 1 );
        // const material = new THREE.MeshLambertMaterial({color: 0x00ffff, transparent: true, opacity: 0.9});
    // const cube = new THREE.Mesh( geometry, material );
    // scene.add( cube );

    // camera.position.z = 5;

    function node(x, y, z) {
        const geometry = new THREE.IcosahedronGeometry( 0.25 + Math.random() * 1.25, 0 );
        const material = new THREE.MeshLambertMaterial({color: 0x88bbff, opacity: 0.9});
        const sphere = new THREE.Mesh( geometry, material );
        sphere.position.set(x, y, z);
        return sphere;
    }

    function edge(pt1, pt2) {
        const material = new THREE.LineBasicMaterial( {color: 0x666fff, transparent: true, opacity: 0.6 } );
        const points = [];
        points.push( new THREE.Vector3( pt1.position.x, pt1.position.y, pt1.position.z ) );
        points.push( new THREE.Vector3( pt2.position.x, pt2.position.y, pt2.position.z ) );

        const geometry = new THREE.BufferGeometry().setFromPoints( points );

        const line = new THREE.Line( geometry, material );

        scene.add(line);
    }

    const nodes = [];
    let gridCt = 50;

    for (let i = -gridCt / 2; i < gridCt / 2; i++) {
        const nodeRow = [];
        for (let j = -gridCt / 2; j < gridCt / 2; j++) {
            let sphere = node(i * 5, -20 + Math.random() * 20, j * 5);
            nodeRow.push(sphere);
            scene.add(sphere);
        }
        nodes.push(nodeRow);
    }

    for (let i = 0; i < gridCt - 1; i++) {
        for (let j = 0; j < gridCt - 1; j++) {
            edge(nodes[i][j], nodes[i + 1][j]);
            edge(nodes[i][j], nodes[i][j+1]);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // cube.rotation.x += 0.01;
        // cube.rotation.y += 0.01;

        controls.update();

        renderer.render( scene, camera );
    };

    animate();
</script> -->

<script type="module">

    // import * as THREE from 'three';

    // import Stats from 'three/addons/libs/stats.module.js';
    // import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    // import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    // import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    // import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    // import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    let camera, stats, scene, db, wireframe;
    let nodes = [];
    let composer, renderer, mixer, clock;

    const params = {
        exposure: 1,
        bloomStrength: 2,
        bloomThreshold: 0,
        bloomRadius: 1
    };

    init();

    function node(x, y, z) {
        const geometry = new THREE.IcosahedronGeometry(0.05, 0);
        const material = new THREE.MeshLambertMaterial({ color: 0x23ae2f, opacity: 0.9 });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(x, y, z);
        // sphere.scale.set(0.5, 0.5, 0.5);
        return sphere;
    }

    function init() {

        const container = document.getElementById('celerity-container');

        // let container = document.getElementById('celerity-container');
        container.className += ' zstack-child';
        let width = window.innerWidth / 2;
        let height = 800;
        // stats = new Stats();
        // container.appendChild(stats.dom);

        clock = new THREE.Clock();

        renderer = new THREE.WebGLRenderer({ antialias: true});
        // renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.autoClear = false;
        renderer.setClearColor(0x00ff00, 0.0);
        renderer.setSize(width, height);
        // renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.domElement.style.float = "right";
        container.appendChild(renderer.domElement);

        scene = new THREE.Scene();

        // scene.background = new THREE.Color(0xff0000);

        camera = new THREE.PerspectiveCamera(40, width / height, 1, 2000);
        camera.position.set(- 5, 2.5, - 3.5);
        scene.add(camera);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.minDistance = 1;
        controls.maxDistance = 10;

        scene.add(new THREE.AmbientLight(0x404040));

        const pointLight = new THREE.PointLight(0xffffff, 1);
        camera.add(pointLight);

        // const renderScene = new THREE.RenderPass(scene, camera);

        // const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        // bloomPass.threshold = params.bloomThreshold;
        // bloomPass.strength = params.bloomStrength;
        // bloomPass.radius = params.bloomRadius;

        // var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };

        // var renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);

        // composer = new THREE.EffectComposer(renderer, renderTarget);
        // // composer.setClearColor(0x000000, 0.0);
        // composer.addPass(renderScene);
        // composer.addPass(bloomPass);

        new THREE.GLTFLoader().load('assets/models/aku.glb', function (gltf) {

            const model = gltf.scene;

            db = model;
            // scene.add(model);

            // mixer = new THREE.AnimationMixer(model);
            // const clip = gltf.animations[0];
            // mixer.clipAction(clip.optimize()).play();

            const geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
            const material = new THREE.MeshLambertMaterial({ color: 0x222222 });
            db = new THREE.Mesh(geometry, material);
            db.position.set(0, 1, 0);
            scene.add(db);


            var geo = new THREE.EdgesGeometry(db.geometry); // or WireframeGeometry
            var mat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            wireframe = new THREE.LineSegments(geo, mat);
            wireframe.position.set(0, 1, 0);
            wireframe.scale.set(1.01, 1.01, 1.01);
            scene.add(wireframe);

            animate();

        });

        // const gui = new GUI();

        // gui.add(params, 'exposure', 0.1, 2).onChange(function (value) {

        //     renderer.toneMappingExposure = Math.pow(value, 4.0);

        // });

        // gui.add(params, 'bloomThreshold', 0.0, 1.0).onChange(function (value) {

        //     bloomPass.threshold = Number(value);

        // });

        for (let i = 0; i < 100; i++) {
            let n = node(1, 1, 1);
            n.orbit = 0;
            n.speed = 0.01 + Math.random() * 0.08;
            // n.scale.set(0.1, 0.1, 0.1);
            let x = Math.sin(360 / 20 * (i + n.orbit)) * 1.5;
            let y = Math.random() * 1 + 0.5;
            let z = Math.cos(360 / 20 * (i + n.orbit)) * 1.5;
            n.position.set(x, y, z);
            n.update = (dt) => {
                n.orbit += n.speed * dt;
                let x = Math.sin(360 / 20 * (i + n.orbit)) * 1.5;
                // let y = Math.random() * 1 + 0.5;
                let z = Math.cos(360 / 20 * (i + n.orbit)) * 1.5;
                n.position.set(x, y, z);
            }
            nodes.push(n);
            scene.add(n);
        }

        // gui.add(params, 'bloomStrength', 0.0, 3.0).onChange(function (value) {

        //     bloomPass.strength = Number(value);

        // });

        // gui.add(params, 'bloomRadius', 0.0, 1.0).step(0.01).onChange(function (value) {

        //     bloomPass.radius = Number(value);

        // });

        window.addEventListener('resize', onWindowResize);

    }

    function onWindowResize() {

        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        // composer.setSize(width, height);

    }

    function animate() {

        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        db.rotation.y += 0.6 * delta;
        wireframe.rotation.y -= 0.6 * delta;

        nodes.forEach((node) => {
            node.update(delta);
        });

        // mixer.update(delta);

        // stats.update();
        // composer.render();
        renderer.render(scene, camera);
    }

</script>